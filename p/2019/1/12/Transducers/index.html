<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel="stylesheet" href="/js/prism.css">
    <link rel="stylesheet" href="/css/app.css">
    <title>Transducers - 叫兽</title>
    <link rel="icon" type="image/x-icon" class="js-site-favicon" href="/img/favicon.ico">
  </head>
  <body>

        <div class="container bg-white pb-5 px-5 spx-0">
            
            <h1 class="post-title">Transducers</h1>




            <p>Transducers是一些组合起来的算法转换，它是把数据的输入输出转换从数据结构解耦的一种方法。解耦之后这些数据就可以自由的重用和组合。可以用于不同的数据流处理：collections, streams,  channels, observables.</p><p>把数据从转换中解耦，将会更简单和更可重用代码。</p><p>Transducers就像一个筛子，输入一份数据，经过筛子组合，然后输出一份数据。</p><p>或者也可以把他比喻做食谱，食物只要经过这个食谱的烹饪，就可以变成一道菜。Transducers是如何处理数据序列的配方，而不知道数据是什么。</p><p>而且最重要的是，Transducers性能非常好，他在数据处理过程中，并不会创建中间集合。</p><p>Here’s a visualisation to show the difference between array built-ins and transducers.</p><p>1 chained built-in transformations create intermediate arrays <img src="/static/2019/1/transducers.gif" alt="" /></p><p>2 transduced transformations process items one by one into output array <img src="/static/2019/1/transducers2.gif" alt="" /></p><p>传统，我们有三种方法来实现数据流的处理：</p><p>1 nested calls<pre><code class=".language-clojure">&#40;reduce + &#40;filter odd? &#40;map #&#40;+ 2 %&#41; &#40;range 0 10&#41;&#41;&#41;&#41;
</code></pre></p><p>2 functional composition<pre><code class=".language-clojure">&#40;def xform
    &#40;comp
    &#40;partial filter odd?&#41;
    &#40;partial map #&#40;+ 2 %&#41;&#41;&#41;&#41;
&#40;reduce + &#40;xform &#40;range 0 10&#41;&#41;&#41;
</code></pre></p><p>3 threading macro<pre><code class=".language-clojure">&#40;defn xform &#91;xs&#93;
    &#40;-&gt;&gt; xs
        &#40;map #&#40;+ 2 %&#41;&#41;
        &#40;filter odd?&#41;&#41;&#41;
&#40;reduce + &#40;xform &#40;range 0 10&#41;&#41;&#41;
</code></pre></p><p>With transducers you will write it like:<pre><code class=".language-clojure">&#40;def xform
  &#40;comp
    &#40;map #&#40;+ 2 %&#41;&#41;
    &#40;filter odd?&#41;&#41;&#41;
&#40;transduce xform + &#40;range 0 10&#41;&#41;
</code></pre></p><p>They all do the same. The difference is that you never call Transducers directly, you pass them to another function. Transducers know what to do, the function that gets transducer knows how. The order of combinators is like you write it with threading macro (natural order). Now you can reuse xform with channel:<pre><code class=".language-clojure">&#40;chan 1 xform&#41;
</code></pre></p><h2>Terminology</h2><p>A reducing function is the kind of function you’d pass to reduce - it is a function that takes an accumulated result and a new input and returns a new accumulated result:</p><pre><code class=".language-clojure">;; reducing function signature  
whatever, input -&gt; whatever
</code></pre><p>A transducer (sometimes referred to as xform or xf) is a transformation from one reducing function to another:</p><pre><code class=".language-clojure">;; transducer signature
&#40;whatever, input -&gt; whatever&#41; -&gt; &#40;whatever, input -&gt; whatever&#41;
</code></pre><h2>Defining Transformations With Transducers</h2><pre><code class=".language-clojure">&#40;filter odd?&#41; ;; returns a transducer that filters odd
&#40;map inc&#41;     ;; returns a mapping transducer for incrementing
&#40;take 5&#41;      ;; returns a transducer that will take the first 5 values
</code></pre><p> The recommended way to compose transducers is with the existing comp function:</p><pre><code class=".language-clojure"> &#40;def xf
  &#40;comp
    &#40;filter odd?&#41;
    &#40;map inc&#41;
    &#40;take 5&#41;&#41;&#41;
 </code></pre><p> The transducer xf is a transformation stack that will be applied by a process to a series of input elements. Each function in the stack is performed before the operation it wraps. Composition of the transformer runs right-to-left but builds a transformation stack that runs left-to-right (filtering happens before mapping in this example).</p><h2>transduce</h2><p>One of the most common ways to apply transducers is with the transduce function, which is analogous to the standard reduce function:</p><pre><code class=".language-clojure">&#40;transduce xform f coll&#41;
&#40;transduce xform f init coll&#41;
</code></pre><p>transduce will immediately (not lazily) reduce over coll with the transducer xform applied to the reducing function f, using init as the initial value if supplied or (f) otherwise. f supplies the knowledge of how to accumulate the result, which occurs in the (potentially stateful) context of the reduce.<pre><code class=".language-clojure">&#40;def xf &#40;comp &#40;filter odd?&#41; &#40;map inc&#41;&#41;&#41;
&#40;transduce xf + &#40;range 5&#41;&#41;
;; =&gt; 6
&#40;transduce xf + 100 &#40;range 5&#41;&#41;
;; =&gt; 106
</code></pre></p><p>The composed xf transducer will be invoked left-to-right with a final call to the reducing function f. In the last example, input values will be filtered, then incremented, and finally summed.</p>
            <p class="text-left text-muted">2019-01-12 13:07</p>
        </div>
        <div class="container">
            <div class="row mt-4">
                <div class="col-6 text-left"></div>
                <div class="col-6 text-right"><a href="/p/2019/1/10/bad-result/">下一篇:坏结果</a></div>
            </div>
        </div>

        <button class="btn btn-link m-menu-toggle d-md-none fixed-top collapsed" type="button" data-toggle="collapse" data-target="#m-menu" aria-controls="m-menu" aria-expanded="false" aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"></path></svg>
        </button>
        <ul class="nav flex-column collapse fixed-top site-menu d-md-block" id="m-menu">
            <li class="nav-item">
                <a class="nav-link" href="/">首页</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/p/list/">所有文章</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/p/about-me/">关于我</a>
            </li>
        </ul>

        
    <div class="container mt-5">
        <h3>留言</h3>
        <div id="commentApp"></div>
    </div>
    <script>
        var AL_configs = {
            "post_id":"/p/2019/1/12/Transducers/",
            "appid":"847e226e8a46f64045d45312245a68ba1368a564"
        };
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://comment.debugmyself.com/sc.js";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


        <footer class="footer mt-5 pb-2">
        <div class="container text-center">
          
          <p><span class="text-black-50">Powered by <a href="https://github.com/arlicle/ablog">ablog</a> © 2019 叫兽</span></p>
          <p><span class="text-black-50">滇ICP备10201832号-3</span></p>
          
        </div>
        </footer>
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
        <script src="/js/prism.js"></script>
        <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip();
        })
        </script>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, displayAlign: "left",scale: 180});
        </script>
        <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG" async>
        </script>
  </body>
</html>